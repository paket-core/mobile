          // Automatically generated by xdrgen 
          // DO NOT EDIT or your changes may be overwritten

          namespace Stellar.Generated
{


// === xdr source ============================================================
//  struct StellarValue
//  {
//      Hash txSetHash;   // transaction set to apply to previous ledger
//      uint64 closeTime; // network close time
//  
//      // upgrades to apply to the previous ledger (usually empty)
//      // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
//      // unknown steps during consensus if needed.
//      // see notes below on 'LedgerUpgrade' for more detail
//      // max size is dictated by number of upgrade types (+ room for future)
//      UpgradeType upgrades<6>;
//  
//      // reserved for future use
//      union switch (int v)
//      {
//      case 0:
//          void;
//      }
//      ext;
//  };
//  ===========================================================================
public class StellarValue {
  public StellarValue () {}
  public Hash TxSetHash { get; set; }
  public Uint64 CloseTime { get; set; }
  public UpgradeType[] Upgrades { get; set; }
  public StellarValueExt Ext { get; set; }
  public static void Encode(IByteWriter stream, StellarValue encodedStellarValue) {
    Hash.Encode(stream, encodedStellarValue.TxSetHash);
    Uint64.Encode(stream, encodedStellarValue.CloseTime);
    int upgradessize = encodedStellarValue.Upgrades.Length;
    XdrEncoding.EncodeInt32(upgradessize, stream);
    for (int i = 0; i < upgradessize; i++) {
      UpgradeType.Encode(stream, encodedStellarValue.Upgrades[i]);
    }
    StellarValueExt.Encode(stream, encodedStellarValue.Ext);
  }
  public static StellarValue Decode(IByteReader stream) {
    StellarValue decodedStellarValue = new StellarValue();
    decodedStellarValue.TxSetHash = Hash.Decode(stream);
    decodedStellarValue.CloseTime = Uint64.Decode(stream);
    int upgradessize = XdrEncoding.DecodeInt32(stream);
    decodedStellarValue.Upgrades = new UpgradeType[upgradessize];
    for (int i = 0; i < upgradessize; i++) {
      decodedStellarValue.Upgrades[i] = UpgradeType.Decode(stream);
    }
    decodedStellarValue.Ext = StellarValueExt.Decode(stream);
    return decodedStellarValue;
  }

  public class StellarValueExt {
    public StellarValueExt () {}
    public int Discriminant { get; set; } = new int();
    public static void Encode(IByteWriter stream, StellarValueExt encodedStellarValueExt) {
    XdrEncoding.EncodeInt32(encodedStellarValueExt.Discriminant, stream);
    switch (encodedStellarValueExt.Discriminant) {
    case 0:
    break;
    }
    }
    public static StellarValueExt Decode(IByteReader stream) {
      StellarValueExt decodedStellarValueExt = new StellarValueExt();
    decodedStellarValueExt.Discriminant = XdrEncoding.DecodeInt32(stream);
    switch (decodedStellarValueExt.Discriminant) {
    case 0:
    break;
    }
      return decodedStellarValueExt;
    }

  }
}
}
